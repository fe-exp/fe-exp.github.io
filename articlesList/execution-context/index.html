<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="importmap">{"imports":{"#entry":"/assets/BYMB3wj2.js"}}</script><title>JavaScript执行上下文与调用栈:深入理解代码执行机制 | 前端技术博客</title><style>a,article,aside,body,details,figcaption,figure,footer,h1,h2,h3,h4,h5,h6,header,main,mark,nav,output,section,summary,time{all:unset;background:none;border:none;color:inherit;display:block;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;padding:0;text-decoration:none}body{font-size:14px}@media screen and (max-width:767px){body{font-size:8px}}</style><style>.defaultTheme[data-v-a2616516]{position:relative;width:100%}.defaultTheme .bg[data-v-a2616516]{inset:0;overflow:hidden;position:absolute;width:100%;z-index:-10}</style><style>.default_header{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:#ffffff50;box-sizing:border-box;display:flex;height:5.21vw;justify-content:space-between;min-height:68px;padding:0 3.5428vw;position:static;top:0;width:100%;z-index:10}.default_header .logo_title{align-items:center;cursor:pointer;display:flex}.default_header .logo_title .logo{margin-right:15px;min-width:50px;width:5.21vw}.default_header .logo_title .title{color:#fff;font-size:3.126vw;font-weight:700}.default_header .menubox{align-items:center;color:#fff;-moz-column-gap:3.5428vw;column-gap:3.5428vw;cursor:pointer;display:flex;font-size:1.3em}</style><style>.execution-context-page[data-v-23f9b775]{background-color:#f8f9fa;box-sizing:border-box;color:#333;font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;line-height:1.6;padding-top:20px}.container[data-v-23f9b775]{margin:0 auto;max-width:900px;padding:0 20px}h1[data-v-23f9b775]{font-size:2.5rem;font-weight:700;margin:0 0 30px;text-align:center;width:100%}.main[data-v-23f9b775]{padding-bottom:3rem}.article[data-v-23f9b775]{background:#fff;border-radius:8px;box-shadow:0 4px 6px #0000001a;padding:2rem}.article section[data-v-23f9b775]{margin-bottom:2.5rem}.article section[data-v-23f9b775]:last-child{margin-bottom:0}.article h2[data-v-23f9b775]{border-bottom:2px solid #e9ecef;color:#4facfe;margin-top:0;padding-bottom:.5rem}.article h3[data-v-23f9b775]{color:#495057;margin-top:1.5rem}.article h4[data-v-23f9b775]{color:#6c757d;margin-bottom:.5rem;margin-top:1rem}.article h5[data-v-23f9b775]{color:#868e96;font-size:.9rem;margin-bottom:.5rem;margin-top:.5rem}.intro[data-v-23f9b775]{font-size:1.1rem;font-weight:500}.visualization[data-v-23f9b775]{background:#f8f9fa;border-radius:8px;margin:2rem 0;padding:1.5rem}.visualization h3[data-v-23f9b775]{color:#4facfe;margin-top:0;text-align:center}.context-diagram .context[data-v-23f9b775]{background:#fff;border-radius:6px;box-shadow:0 2px 4px #0000000d;padding:1rem}.context-diagram .context h4[data-v-23f9b775]{color:#4facfe;margin-top:0;text-align:center}.context-components[data-v-23f9b775]{display:grid;gap:1rem;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;margin-top:1rem}.context-components .component[data-v-23f9b775]{background:#e9ecef;border-radius:4px;padding:.75rem}.context-components .component h5[data-v-23f9b775]{margin-top:0;text-align:center}.component-items[data-v-23f9b775]{border:1px dashed #ced4da;border-radius:4px;min-height:60px;padding:.5rem}.component-items .item[data-v-23f9b775]{background:#fff;border-radius:4px;font-size:.8rem;margin:.25rem 0;padding:.25rem .5rem;text-align:center}.call-stack-diagram[data-v-23f9b775]{align-items:flex-start;display:flex;gap:2rem}.call-stack-diagram .stack[data-v-23f9b775]{background:#fff;border-radius:6px;box-shadow:0 2px 4px #0000000d;flex:1;padding:1rem}.call-stack-diagram .stack h4[data-v-23f9b775]{color:#4facfe;margin-top:0;text-align:center}.call-stack-diagram .explanation[data-v-23f9b775]{background:#e9ecef;border-radius:6px;flex:1;padding:1rem}.call-stack-diagram .explanation p[data-v-23f9b775]{margin:.5rem 0}.stack-items[data-v-23f9b775]{border:1px solid #ced4da;border-radius:4px;display:flex;flex-direction:column-reverse;min-height:200px;padding:.5rem}.stack-items .stack-item[data-v-23f9b775]{background:#4facfe;border-radius:4px;color:#fff;font-size:.9rem;margin:.25rem 0;padding:.5rem;text-align:center}.feature-card[data-v-23f9b775]{background:#f8f9fa;border-left:4px solid #4facfe;border-radius:8px;margin-bottom:1.5rem;padding:1.5rem}.feature-card h3[data-v-23f9b775]{color:#4facfe;margin-top:0}.code-example[data-v-23f9b775]{background:#2d2d2d;border-radius:4px;color:#f8f9fa;margin:1rem 0;overflow-x:auto;padding:1rem}.code-example h3[data-v-23f9b775],.code-example h4[data-v-23f9b775]{color:#f8f9fa;font-size:1rem;margin-bottom:.5rem;margin-top:0}.code-example pre[data-v-23f9b775]{margin:0}.code-example pre code[data-v-23f9b775]{font-family:Fira Code,monospace;font-size:.9rem;line-height:1.5}ul[data-v-23f9b775]{padding-left:1.5rem}ul li[data-v-23f9b775]{margin-bottom:.5rem}.conclusion[data-v-23f9b775]{background:#e6f7ff;border-radius:8px;padding:1.5rem}.conclusion h2[data-v-23f9b775]{border-bottom:none;color:#1890ff}@media (max-width:768px){.header[data-v-23f9b775]{padding:2rem 0}.header h1[data-v-23f9b775]{font-size:2rem}.article[data-v-23f9b775]{padding:1.5rem}.context-components[data-v-23f9b775]{grid-template-columns:1fr}.call-stack-diagram[data-v-23f9b775]{flex-direction:column}.code-example pre code[data-v-23f9b775]{font-size:.8rem}}.feature-card[data-v-23f9b775]{transition:transform .3s ease,box-shadow .3s ease}.feature-card[data-v-23f9b775]:hover{box-shadow:0 6px 12px #0000001a;transform:translateY(-5px)}.code-example pre[data-v-23f9b775]{transition:opacity .3s ease}.code-example pre[data-v-23f9b775]:hover{opacity:.9}.item[data-v-23f9b775],.stack-item[data-v-23f9b775]{transition:transform .2s ease}.item[data-v-23f9b775]:hover,.stack-item[data-v-23f9b775]:hover{box-shadow:0 2px 4px #0000001a;transform:scale(1.02)}</style><style>.footer_cus{background-color:#efefef;box-sizing:border-box;flex-direction:column;height:10.42vw;min-height:88px;padding-top:1.8756vw;width:100%}.footer_cus,.footer_cus .logoRow{display:flex;justify-content:space-between}.footer_cus .logoRow{align-items:center;flex-wrap:wrap;padding:0 6.6688vw}.footer_cus .logoRow .logo_fTitle{align-items:center;cursor:pointer;display:flex}.footer_cus .logoRow .logo_fTitle .logo{margin-right:.7815vw;width:5.21vw}.footer_cus .logoRow .logo_fTitle .title{color:#000;font-size:3.126vw;font-weight:700}.footer_cus .logoRow .menubox_f{align-items:center;color:#000;-moz-column-gap:3.5428vw;column-gap:3.5428vw;cursor:pointer;display:flex;font-size:1.3em}.footer_cus .copyright{border-top:1px solid rgba(0,0,0,.063);color:#00000090;font-size:.8em;line-height:30px;margin-top:auto;text-align:center;width:100%}</style><link rel="stylesheet" href="/assets/entry.DTS0PZ0l.css" crossorigin><link rel="preload" as="fetch" crossorigin="anonymous" href="/articlesList/execution-context/_payload.json?d8732c21-408f-4757-a05a-6bb9ca98505a"><link rel="modulepreload" as="script" crossorigin href="/assets/BYMB3wj2.js"><link rel="modulepreload" as="script" crossorigin href="/assets/B_UYT6rR.js"><link rel="modulepreload" as="script" crossorigin href="/assets/D9QU0F_E.js"><link rel="modulepreload" as="script" crossorigin href="/assets/BxipngAD.js"><link rel="preload" as="fetch" fetchpriority="low" crossorigin="anonymous" href="/assets/builds/meta/d8732c21-408f-4757-a05a-6bb9ca98505a.json"><link rel="prefetch" as="script" crossorigin href="/assets/CDGrM_S6.js"><link rel="prefetch" as="script" crossorigin href="/assets/Bm2hnUHE.js"><link rel="prefetch" as="image" type="image/png" href="/assets/favicon.DAnBlHWS.png"><link rel="prefetch" as="video" href="/assets/bg.PfeklyBa.mp4"><meta name="title" content="fe-exp"><meta name="keywords" content="JavaScript执行上下文, 调用栈, 作用域链, this绑定, 变量提升, 闭包, 前端开发, JavaScript原理"><meta name="description" content="本文深入探讨JavaScript执行上下文和调用栈的概念、工作原理、类型以及实际应用。理解JavaScript代码执行的核心机制,提升编程能力。"><meta property="og:title" content="JavaScript执行上下文与调用栈:深入理解代码执行机制"><meta property="og:description" content="全面解析JavaScript执行上下文和调用栈的概念、工作原理和应用场景,帮助开发者掌握JavaScript代码执行的核心机制。"><meta property="og:type" content="article"><meta property="og:url" content="https://yourwebsite.com/articles/execution-context"><meta property="og:image" content="https://yourwebsite.com/images/execution-context-article.jpg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="JavaScript执行上下文与调用栈:深入理解代码执行机制"><meta name="twitter:description" content="全面解析JavaScript执行上下文和调用栈的概念、工作原理和应用场景,帮助开发者掌握JavaScript代码执行的核心机制。"><meta name="twitter:image" content="https://yourwebsite.com/images/execution-context-article.jpg"><script type="module" src="/assets/BYMB3wj2.js" crossorigin></script></head><body><div id="__nuxt"><div class="defaultTheme" data-v-a2616516><header class="default_header" data-v-a2616516><a href="/" title="Home Page"><div class="logo_title"><img src="/assets/favicon.DAnBlHWS.png" alt="feexp 网站logo | fe-exp专注前端开发,分享技术干货。" class="logo"><div class="title">FEEXP</div></div></a><div class="menubox"><a href="/" title="Home Page"><div class="menu">Home</div></a><a href="/articlesList" title="Articles List"><div class="menu">Articles</div></a><a href="/onlineTools" title="Online Tools"><div class="menu">Online Tools</div></a><a href="/about" title="About"><div class="menu">About</div></a></div></header><div class="execution-context-page" data-v-23f9b775><h1 data-v-23f9b775>JavaScript执行上下文与调用栈:深入理解代码执行机制</h1><main class="main container" data-v-23f9b775><article class="article" data-v-23f9b775><section class="intro" data-v-23f9b775><p data-v-23f9b775>执行上下文和调用栈是JavaScript代码执行的核心机制,理解这些概念对于掌握JavaScript的运行原理至关重要。本文将深入探讨执行上下文的类型、创建过程、调用栈的工作原理以及它们在实际开发中的应用,帮助你写出更高效、更易维护的JavaScript代码。</p></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>什么是执行上下文？</h2><p data-v-23f9b775><strong data-v-23f9b775>执行上下文</strong>是JavaScript代码被评估和执行的环境的抽象概念。每当JavaScript代码运行时,它都在某个执行上下文中执行。执行上下文包含了代码执行所需的所有信息,包括变量、函数、作用域链和this绑定。</p><div class="visualization" data-v-23f9b775><h3 data-v-23f9b775>执行上下文结构</h3><div class="context-diagram" data-v-23f9b775><div class="context" data-v-23f9b775><h4 data-v-23f9b775>执行上下文 (Execution Context)</h4><div class="context-components" data-v-23f9b775><div class="component" data-v-23f9b775><h5 data-v-23f9b775>变量环境 (Variable Environment)</h5><div class="component-items" data-v-23f9b775><!--[--><div class="item" data-v-23f9b775>var 声明</div><div class="item" data-v-23f9b775>函数声明</div><!--]--></div></div><div class="component" data-v-23f9b775><h5 data-v-23f9b775>词法环境 (Lexical Environment)</h5><div class="component-items" data-v-23f9b775><!--[--><div class="item" data-v-23f9b775>let/const 声明</div><div class="item" data-v-23f9b775>块级作用域</div><!--]--></div></div><div class="component" data-v-23f9b775><h5 data-v-23f9b775>this绑定 (This Binding)</h5><div class="component-items" data-v-23f9b775><div class="item" data-v-23f9b775>当前上下文this值</div></div></div><div class="component" data-v-23f9b775><h5 data-v-23f9b775>外部环境引用 (Outer Reference)</h5><div class="component-items" data-v-23f9b775><div class="item" data-v-23f9b775>指向外部环境</div></div></div></div></div></div></div></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>执行上下文的类型</h2><p data-v-23f9b775>JavaScript中有三种类型的执行上下文:</p><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>1. 全局执行上下文</h3><p data-v-23f9b775>这是默认的、最外层的执行上下文。在浏览器中,全局上下文是window对象,在Node.js中是global对象。每个JavaScript程序只有一个全局执行上下文。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>// 全局变量
var globalVar = &quot;我在全局上下文中&quot;;

// 全局函数
function globalFunction() {
  console.log(&quot;我也是在全局上下文中&quot;);
}

// 在浏览器中,this指向window
console.log(this === window); // true (在浏览器中)

// 全局上下文中声明的变量和函数成为全局对象的属性
console.log(window.globalVar); // &quot;我在全局上下文中&quot;
console.log(window.globalFunction); // function globalFunction()</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>2. 函数执行上下文</h3><p data-v-23f9b775>每当函数被调用时,就会创建一个新的函数执行上下文。每个函数都有自己的执行上下文,即使调用的是同一个函数。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>function outerFunction() {
  // 外部函数执行上下文
  var outerVar = &quot;我在外部函数上下文中&quot;;
  
  function innerFunction() {
    // 内部函数执行上下文
    var innerVar = &quot;我在内部函数上下文中&quot;;
    console.log(outerVar); // 可以访问外部函数的变量
    console.log(innerVar); // 可以访问自己的变量
  }
  
  innerFunction();
  // console.log(innerVar); // 错误: innerVar未定义
}

outerFunction();

// 多次调用同一函数创建多个执行上下文
function counter() {
  let count = 0; // 每个执行上下文有自己的count变量
  return function() {
    count++;
    return count;
  };
}

const counter1 = counter();
const counter2 = counter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (独立的执行上下文)</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>3. Eval函数执行上下文</h3><p data-v-23f9b775>在eval函数内部执行的代码也会获得自己的执行上下文。但由于安全和性能原因,一般不推荐使用eval。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>var x = 10;

function testEval() {
  var y = 20;
  eval(&#39;var z = 30; console.log(x + y + z);&#39;); // 60
  // console.log(z); // 30 (在严格模式下会报错)
}

testEval();

// 注意: 在严格模式下,eval代码不会创建新的变量环境
// 使用eval可能导致性能问题和安全漏洞,应避免使用</code></pre></div></div></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>执行上下文的创建阶段</h2><p data-v-23f9b775>执行上下文的创建分为两个阶段:创建阶段和执行阶段。</p><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>1. 创建阶段</h3><p data-v-23f9b775>在创建阶段,JavaScript引擎会:</p><ul data-v-23f9b775><li data-v-23f9b775>创建变量对象（VO）/激活对象（AO）</li><li data-v-23f9b775>建立作用域链</li><li data-v-23f9b775>确定this的值</li></ul><div class="code-example" data-v-23f9b775><h4 data-v-23f9b775>变量提升示例</h4><pre data-v-23f9b775><code data-v-23f9b775>console.log(a); // undefined (变量提升)
var a = 10;

console.log(b); // 错误: b未定义 (let/const不会提升)
let b = 20;

console.log(c()); // &quot;Hello&quot; (函数声明提升)
function c() {
  return &quot;Hello&quot;;
}

console.log(d); // undefined (变量提升)
var d = function() {
  return &quot;World&quot;;
};</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>2. 执行阶段</h3><p data-v-23f9b775>在执行阶段,JavaScript引擎会:</p><ul data-v-23f9b775><li data-v-23f9b775>执行代码</li><li data-v-23f9b775>分配变量值</li><li data-v-23f9b775>执行函数调用</li></ul><div class="code-example" data-v-23f9b775><h4 data-v-23f9b775>执行过程示例</h4><pre data-v-23f9b775><code data-v-23f9b775>// 创建阶段:
// 1. 变量a被声明并初始化为undefined
// 2. 函数foo被创建
// 3. 变量b被声明但不初始化（暂时性死区）

// 执行阶段:
console.log(a); // undefined
var a = 10;

function foo() {
  console.log(&quot;函数执行&quot;);
}

console.log(a); // 10

// let b = 20; // 如果取消注释,上面console.log(b)会报错

foo(); // &quot;函数执行&quot;</code></pre></div></div></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>调用栈（Call Stack）</h2><p data-v-23f9b775><strong data-v-23f9b775>调用栈</strong>是一种数据结构,用于跟踪多个函数调用。它是一个后进先出（LIFO）的栈,用于存储执行上下文。</p><div class="visualization" data-v-23f9b775><h3 data-v-23f9b775>调用栈工作原理</h3><div class="call-stack-diagram" data-v-23f9b775><div class="stack" data-v-23f9b775><h4 data-v-23f9b775>调用栈 (LIFO)</h4><div class="stack-items" data-v-23f9b775><!--[--><div class="stack-item" data-v-23f9b775>third() 执行上下文</div><div class="stack-item" data-v-23f9b775>second() 执行上下文</div><div class="stack-item" data-v-23f9b775>first() 执行上下文</div><div class="stack-item" data-v-23f9b775>全局执行上下文</div><!--]--></div></div><div class="explanation" data-v-23f9b775><p data-v-23f9b775>当函数被调用时,其执行上下文被压入调用栈</p><p data-v-23f9b775>当函数执行完成后,其执行上下文从调用栈弹出</p><p data-v-23f9b775>栈顶的执行上下文是当前正在执行的上下文</p></div></div></div><div class="code-example" data-v-23f9b775><h3 data-v-23f9b775>调用栈示例</h3><pre data-v-23f9b775><code data-v-23f9b775>function first() {
  console.log(&quot;第一个函数开始&quot;);
  second();
  console.log(&quot;第一个函数结束&quot;);
}

function second() {
  console.log(&quot;第二个函数开始&quot;);
  third();
  console.log(&quot;第二个函数结束&quot;);
}

function third() {
  console.log(&quot;第三个函数开始&quot;);
  console.log(&quot;第三个函数结束&quot;);
}

console.log(&quot;全局代码开始&quot;);
first();
console.log(&quot;全局代码结束&quot;);

// 输出顺序:
// 全局代码开始
// 第一个函数开始
// 第二个函数开始
// 第三个函数开始
// 第三个函数结束
// 第二个函数结束
// 第一个函数结束
// 全局代码结束</code></pre></div></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>作用域链与闭包</h2><p data-v-23f9b775>执行上下文包含一个作用域链,用于解析变量和函数引用。闭包的形成与作用域链密切相关。</p><div class="code-example" data-v-23f9b775><h3 data-v-23f9b775>作用域链示例</h3><pre data-v-23f9b775><code data-v-23f9b775>var globalVar = &quot;全局变量&quot;;

function outer() {
  var outerVar = &quot;外部变量&quot;;
  
  function inner() {
    var innerVar = &quot;内部变量&quot;;
    console.log(innerVar); // 内部变量 (当前作用域)
    console.log(outerVar); // 外部变量 (外部作用域)
    console.log(globalVar); // 全局变量 (全局作用域)
  }
  
  return inner;
}

var closure = outer();
closure();

// 作用域链: inner → outer → global</code></pre></div><div class="code-example" data-v-23f9b775><h3 data-v-23f9b775>闭包与执行上下文</h3><pre data-v-23f9b775><code data-v-23f9b775>function createCounter() {
  // createCounter的执行上下文
  let count = 0;
  
  return function() {
    // 内部函数的执行上下文
    // 但可以访问createCounter的执行上下文中的变量
    count++;
    return count;
  };
}

// counter1和counter2有各自独立的执行上下文
const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (独立的闭包)
console.log(counter1()); // 3

// 即使createCounter的执行已经结束,
// 其执行上下文仍然被内部函数引用（闭包）</code></pre></div></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>this绑定规则</h2><p data-v-23f9b775>执行上下文中的this值取决于函数的调用方式。JavaScript有四种this绑定规则:</p><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>1. 默认绑定</h3><p data-v-23f9b775>在独立函数调用中,this指向全局对象（非严格模式）或undefined（严格模式）。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>function showThis() {
  console.log(this);
}

showThis(); // Window (浏览器中) / global (Node.js中)

// 严格模式
function strictShowThis() {
  &quot;use strict&quot;;
  console.log(this);
}

strictShowThis(); // undefined</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>2. 隐式绑定</h3><p data-v-23f9b775>当函数作为对象的方法调用时,this指向该对象。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>const obj = {
  name: &quot;我的对象&quot;,
  getName: function() {
    return this.name;
  }
};

console.log(obj.getName()); // &quot;我的对象&quot;

// 注意: 回调函数中的this可能丢失
const extractedFunc = obj.getName;
console.log(extractedFunc()); // undefined (默认绑定)</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>3. 显式绑定</h3><p data-v-23f9b775>使用call、apply或bind方法显式设置this值。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>function introduce(lang1, lang2) {
  console.log(`我是${this.name},我会${lang1}和${lang2}`);
}

const person1 = { name: &quot;张三&quot; };
const person2 = { name: &quot;李四&quot; };

// 使用call
introduce.call(person1, &quot;JavaScript&quot;, &quot;Python&quot;);
// 我是张三,我会JavaScript和Python

// 使用apply
introduce.apply(person2, [&quot;Java&quot;, &quot;C++&quot;]);
// 我是李四,我会Java和C++

// 使用bind
const introducePerson1 = introduce.bind(person1, &quot;Ruby&quot;, &quot;Go&quot;);
introducePerson1(); // 我是张三,我会Ruby和Go</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>4. new绑定</h3><p data-v-23f9b775>使用new关键字调用构造函数时,this指向新创建的对象。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>function Person(name, age) {
  // this指向新创建的对象
  this.name = name;
  this.age = age;
  
  this.introduce = function() {
    return `我叫${this.name},今年${this.age}岁`;
  };
}

const person = new Person(&quot;王五&quot;, 25);
console.log(person.introduce()); // 我叫王五,今年25岁</code></pre></div></div></section><section class="content-section" data-v-23f9b775><h2 data-v-23f9b775>执行上下文在实际开发中的应用</h2><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>1. 调试调用栈溢出</h3><p data-v-23f9b775>理解调用栈有助于诊断和修复栈溢出错误。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>// 无限递归导致调用栈溢出
function infiniteRecursion() {
  infiniteRecursion(); // 不断压入调用栈,最终溢出
}

// 避免栈溢出的方法 - 使用尾调用优化
function factorial(n, acc = 1) {
  if (n &lt;= 1) return acc;
  return factorial(n - 1, n * acc); // 尾调用
}

// 或者使用迭代替代递归
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i &lt;= n; i++) {
    result *= i;
  }
  return result;
}</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>2. 理解异步代码执行</h3><p data-v-23f9b775>理解执行上下文和事件循环的关系,有助于编写正确的异步代码。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>console.log(&quot;开始&quot;);

setTimeout(function() {
  console.log(&quot;setTimeout回调&quot;);
}, 0);

Promise.resolve().then(function() {
  console.log(&quot;Promise回调&quot;);
});

console.log(&quot;结束&quot;);

// 输出顺序:
// 开始
// 结束
// Promise回调
// setTimeout回调

// 解释:
// 1. 同步代码执行,创建执行上下文
// 2. setTimeout和Promise回调被添加到任务队列
// 3. 当调用栈为空时,事件循环将微任务(Promise)推入调用栈
// 4. 然后事件循环将宏任务(setTimeout)推入调用栈</code></pre></div></div><div class="feature-card" data-v-23f9b775><h3 data-v-23f9b775>3. 模块模式和闭包</h3><p data-v-23f9b775>利用执行上下文和闭包创建私有变量和模块。</p><div class="code-example" data-v-23f9b775><pre data-v-23f9b775><code data-v-23f9b775>// 模块模式
const myModule = (function() {
  // 私有变量
  let privateCounter = 0;
  
  // 私有函数
  function privateFunction() {
    return &quot;私有&quot;;
  }
  
  // 公有API
  return {
    increment: function() {
      privateCounter++;
    },
    
    getValue: function() {
      return privateCounter;
    },
    
    publicFunction: function() {
      return &quot;公有,调用&quot; + privateFunction();
    }
  };
})();

console.log(myModule.getValue()); // 0
myModule.increment();
console.log(myModule.getValue()); // 1
console.log(myModule.publicFunction()); // &quot;公有,调用私有&quot;
// console.log(myModule.privateCounter); // undefined
// myModule.privateFunction(); // 错误</code></pre></div></div></section><section class="conclusion" data-v-23f9b775><h2 data-v-23f9b775>总结</h2><p data-v-23f9b775>执行上下文和调用栈是JavaScript运行时的核心机制,理解这些概念对于掌握JavaScript语言特性至关重要。执行上下文提供了代码执行的环境,而调用栈则管理着多个执行上下文的执行顺序。</p><p data-v-23f9b775>关键要点:</p><ul data-v-23f9b775><li data-v-23f9b775>JavaScript有三种执行上下文:全局、函数和eval</li><li data-v-23f9b775>执行上下文创建分为两个阶段:创建阶段和执行阶段</li><li data-v-23f9b775>调用栈是后进先出的数据结构,用于管理执行上下文</li><li data-v-23f9b775>作用域链决定了变量的可访问性,是闭包实现的基础</li><li data-v-23f9b775>this绑定取决于函数的调用方式,有四种绑定规则</li><li data-v-23f9b775>理解这些概念有助于编写更好的异步代码和模块化代码</li></ul><p data-v-23f9b775>深入理解执行上下文和调用栈将帮助你写出更高效、更可靠的JavaScript代码,并更好地调试复杂的问题。</p></section></article></main></div><footer class="footer_cus" data-v-a2616516><div class="logoRow"><a href="/" title="Home Page"><div class="logo_fTitle"><img src="/assets/favicon.DAnBlHWS.png" alt="feexp 网站logo | fe-exp专注前端开发,分享技术干货。" class="logo"><div class="title">FEEXP</div></div></a><div class="menubox_f"><a href="/articlesList" title="Articles List"><div class="menu">Articles</div></a><a href="/onlineTools" title="Online Tools"><div class="menu">Online Tools</div></a><a href="/about" title="About"><div class="menu">About</div></a></div></div><div class="copyright">Copyright © 2025 feexp.github.io Individuals and their licensors. All rights reserved.</div></footer><div class="bg" data-v-a2616516><video autoplay class="bg_video" muted loop width="100%" data-v-a2616516><source src="/assets/bg.PfeklyBa.mp4" data-v-a2616516></video></div></div></div><div id="teleports"></div><script type="application/json" data-nuxt-data="nuxt-app" data-ssr="true" id="__NUXT_DATA__" data-src="/articlesList/execution-context/_payload.json?d8732c21-408f-4757-a05a-6bb9ca98505a">[{"state":1,"once":3,"_errors":4,"serverRendered":6,"path":7,"prerenderedAt":8},["Reactive",2],{},["Set"],["ShallowReactive",5],{},true,"/articlesList/execution-context",1758186392757]</script><script>window.__NUXT__={};window.__NUXT__.config={public:{supabase:{url:"",key:""}},app:{baseURL:"/",buildId:"d8732c21-408f-4757-a05a-6bb9ca98505a",buildAssetsDir:"assets",cdnURL:""}}</script></body></html>