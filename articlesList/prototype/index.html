<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="importmap">{"imports":{"#entry":"/assets/BYMB3wj2.js"}}</script><title>JavaScript原型与原型链:深入理解对象继承机制 | 前端技术博客</title><style>a,article,aside,body,details,figcaption,figure,footer,h1,h2,h3,h4,h5,h6,header,main,mark,nav,output,section,summary,time{all:unset;background:none;border:none;color:inherit;display:block;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;padding:0;text-decoration:none}body{font-size:14px}@media screen and (max-width:767px){body{font-size:8px}}</style><style>.defaultTheme[data-v-a2616516]{position:relative;width:100%}.defaultTheme .bg[data-v-a2616516]{inset:0;overflow:hidden;position:absolute;width:100%;z-index:-10}</style><style>.default_header{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:#ffffff50;box-sizing:border-box;display:flex;height:5.21vw;justify-content:space-between;min-height:68px;padding:0 3.5428vw;position:static;top:0;width:100%;z-index:10}.default_header .logo_title{align-items:center;cursor:pointer;display:flex}.default_header .logo_title .logo{margin-right:15px;min-width:50px;width:5.21vw}.default_header .logo_title .title{color:#fff;font-size:3.126vw;font-weight:700}.default_header .menubox{align-items:center;color:#fff;-moz-column-gap:3.5428vw;column-gap:3.5428vw;cursor:pointer;display:flex;font-size:1.3em}</style><style>.prototype-page[data-v-8b43f027]{background-color:#f8f9fa;box-sizing:border-box;color:#333;font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;line-height:1.6;padding-top:20px}.container[data-v-8b43f027]{margin:0 auto;max-width:800px;padding:0 20px}h1[data-v-8b43f027]{font-size:2.5rem;font-weight:700;margin:0 0 30px;text-align:center;width:100%}.main[data-v-8b43f027]{padding-bottom:3rem}.article[data-v-8b43f027]{background:#fff;border-radius:8px;box-shadow:0 4px 6px #0000001a;padding:2rem}.article section[data-v-8b43f027]{margin-bottom:2.5rem}.article section[data-v-8b43f027]:last-child{margin-bottom:0}.article h2[data-v-8b43f027]{border-bottom:2px solid #e9ecef;color:#2575fc;margin-top:0;padding-bottom:.5rem}.article h3[data-v-8b43f027]{color:#495057;margin-top:1.5rem}.intro[data-v-8b43f027]{font-size:1.1rem;font-weight:500}.code-example[data-v-8b43f027]{background:#f8f9fa;border-left:4px solid #2575fc;border-radius:0 4px 4px 0;margin:1.5rem 0;padding:1rem}.code-example h3[data-v-8b43f027]{color:#2575fc;margin-top:0}.code-example pre[data-v-8b43f027]{background:#2d2d2d;border-radius:4px;color:#f8f9fa;margin:0;overflow-x:auto;padding:1rem}.code-example pre code[data-v-8b43f027]{font-family:Fira Code,monospace;font-size:.9rem;line-height:1.5}ul[data-v-8b43f027]{padding-left:1.5rem}ul li[data-v-8b43f027]{margin-bottom:.5rem}.conclusion[data-v-8b43f027]{background:#e9f7ff;border-radius:8px;padding:1.5rem}.conclusion h2[data-v-8b43f027]{border-bottom:none;color:#1890ff}@media (max-width:768px){.header[data-v-8b43f027]{padding:2rem 0}.header h1[data-v-8b43f027]{font-size:2rem}.article[data-v-8b43f027]{padding:1.5rem}.code-example pre code[data-v-8b43f027]{font-size:.8rem}}.content-section[data-v-8b43f027]{transition:transform .3s ease}.content-section[data-v-8b43f027]:hover{transform:translate(5px)}.code-example pre[data-v-8b43f027]{transition:background-color .3s ease}.code-example pre[data-v-8b43f027]:hover{background-color:#3d3d3d}</style><style>.footer_cus{background-color:#efefef;box-sizing:border-box;flex-direction:column;height:10.42vw;min-height:88px;padding-top:1.8756vw;width:100%}.footer_cus,.footer_cus .logoRow{display:flex;justify-content:space-between}.footer_cus .logoRow{align-items:center;flex-wrap:wrap;padding:0 6.6688vw}.footer_cus .logoRow .logo_fTitle{align-items:center;cursor:pointer;display:flex}.footer_cus .logoRow .logo_fTitle .logo{margin-right:.7815vw;width:5.21vw}.footer_cus .logoRow .logo_fTitle .title{color:#000;font-size:3.126vw;font-weight:700}.footer_cus .logoRow .menubox_f{align-items:center;color:#000;-moz-column-gap:3.5428vw;column-gap:3.5428vw;cursor:pointer;display:flex;font-size:1.3em}.footer_cus .copyright{border-top:1px solid rgba(0,0,0,.063);color:#00000090;font-size:.8em;line-height:30px;margin-top:auto;text-align:center;width:100%}</style><link rel="stylesheet" href="/assets/entry.DTS0PZ0l.css" crossorigin><link rel="preload" as="fetch" crossorigin="anonymous" href="/articlesList/prototype/_payload.json?d8732c21-408f-4757-a05a-6bb9ca98505a"><link rel="modulepreload" as="script" crossorigin href="/assets/BYMB3wj2.js"><link rel="modulepreload" as="script" crossorigin href="/assets/B_UYT6rR.js"><link rel="modulepreload" as="script" crossorigin href="/assets/Ds1uoWwM.js"><link rel="modulepreload" as="script" crossorigin href="/assets/BxipngAD.js"><link rel="preload" as="fetch" fetchpriority="low" crossorigin="anonymous" href="/assets/builds/meta/d8732c21-408f-4757-a05a-6bb9ca98505a.json"><link rel="prefetch" as="script" crossorigin href="/assets/CDGrM_S6.js"><link rel="prefetch" as="script" crossorigin href="/assets/Bm2hnUHE.js"><link rel="prefetch" as="image" type="image/png" href="/assets/favicon.DAnBlHWS.png"><link rel="prefetch" as="video" href="/assets/bg.PfeklyBa.mp4"><meta name="title" content="fe-exp"><meta name="keywords" content="JavaScript原型, 原型链, 对象继承, 面向对象编程, 前端开发, JavaScript继承, 原型编程"><meta name="description" content="本文深入探讨JavaScript原型和原型链的概念、工作原理、应用场景以及在实际开发中的使用。理解JavaScript对象继承机制的核心概念。"><meta property="og:title" content="JavaScript原型与原型链:深入理解对象继承机制"><meta property="og:description" content="全面解析JavaScript原型和原型链的概念、工作原理和应用场景,帮助开发者掌握JavaScript对象继承机制。"><meta property="og:type" content="article"><meta property="og:url" content="https://yourwebsite.com/articles/javascript-prototype"><meta property="og:image" content="https://yourwebsite.com/images/javascript-prototype-article.jpg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="JavaScript原型与原型链:深入理解对象继承机制"><meta name="twitter:description" content="全面解析JavaScript原型和原型链的概念、工作原理和应用场景,帮助开发者掌握JavaScript对象继承机制。"><meta name="twitter:image" content="https://yourwebsite.com/images/javascript-prototype-article.jpg"><script type="module" src="/assets/BYMB3wj2.js" crossorigin></script></head><body><div id="__nuxt"><div class="defaultTheme" data-v-a2616516><header class="default_header" data-v-a2616516><a href="/" title="Home Page"><div class="logo_title"><img src="/assets/favicon.DAnBlHWS.png" alt="feexp 网站logo | fe-exp专注前端开发,分享技术干货。" class="logo"><div class="title">FEEXP</div></div></a><div class="menubox"><a href="/" title="Home Page"><div class="menu">Home</div></a><a href="/articlesList" title="Articles List"><div class="menu">Articles</div></a><a href="/onlineTools" title="Online Tools"><div class="menu">Online Tools</div></a><a href="/about" title="About"><div class="menu">About</div></a></div></header><div class="prototype-page" data-v-8b43f027><h1 data-v-8b43f027>JavaScript原型与原型链:深入理解对象继承机制</h1><main class="main container" data-v-8b43f027><article class="article" data-v-8b43f027><section class="intro" data-v-8b43f027><p data-v-8b43f027>原型和原型链是JavaScript中对象继承的核心机制,也是JavaScript区别于其他面向对象语言的重要特性。理解原型和原型链对于掌握JavaScript至关重要。本文将深入探讨原型和原型链的概念、工作原理以及实际应用。</p></section><section class="content-section" data-v-8b43f027><h2 data-v-8b43f027>什么是原型？</h2><p data-v-8b43f027>在JavaScript中,每个对象都有一个隐藏的<strong data-v-8b43f027>原型(prototype)</strong>属性,它指向另一个对象或者null。当我们访问一个对象的属性时,如果该对象本身没有这个属性,JavaScript引擎会沿着原型链向上查找,直到找到该属性或者到达原型链的末端(null)。</p><div class="code-example" data-v-8b43f027><h3 data-v-8b43f027>原型的基本示例</h3><pre data-v-8b43f027><code data-v-8b43f027>// 创建一个对象
const person = {
  name: &#39;张三&#39;,
  age: 30,
  greet() {
    return `你好,我是${this.name}`;
  }
};

// 使用Object.create基于现有对象创建新对象
const student = Object.create(person);
student.grade = &#39;大三&#39;;
student.study = function() {
  return `${this.name}正在学习`;
};

console.log(student.name); // 输出: 张三 - 从原型继承
console.log(student.grade); // 输出: 大三 - 自有属性
console.log(student.greet()); // 输出: 你好,我是张三 - 从原型继承</code></pre></div></section><section class="content-section" data-v-8b43f027><h2 data-v-8b43f027>理解原型链</h2><p data-v-8b43f027><strong data-v-8b43f027>原型链</strong>是由对象通过原型连接起来形成的链式结构。当访问一个对象的属性时,JavaScript引擎会首先在对象自身属性中查找,如果找不到,就会沿着原型链向上查找,直到找到该属性或到达原型链的末端(null)。</p><div class="code-example" data-v-8b43f027><h3 data-v-8b43f027>原型链示例</h3><pre data-v-8b43f027><code data-v-8b43f027>// 基对象
const animal = {
  eats: true,
  walk() {
    return &#39;动物在行走&#39;;
  }
};

// 基于animal创建rabbit
const rabbit = Object.create(animal);
rabbit.jumps = true;
rabbit.walk = function() {
  return &#39;兔子蹦蹦跳跳&#39;;
};

// 基于rabbit创建longEar
const longEar = Object.create(rabbit);
longEar.earLength = &#39;10cm&#39;;

console.log(longEar.jumps); // true (从rabbit继承)
console.log(longEar.eats); // true (从animal继承)
console.log(longEar.walk()); // &#39;兔子蹦蹦跳跳&#39; (从rabbit继承,覆盖了animal的walk)

// 检查原型关系
console.log(Object.getPrototypeOf(longEar) === rabbit); // true
console.log(rabbit.isPrototypeOf(longEar)); // true
console.log(animal.isPrototypeOf(longEar)); // true</code></pre></div></section><section class="content-section" data-v-8b43f027><h2 data-v-8b43f027>构造函数与原型</h2><p data-v-8b43f027>在JavaScript中,函数也是对象,每个函数都有一个<code data-v-8b43f027>prototype</code>属性。当使用<code data-v-8b43f027>new</code>关键字调用函数时,会创建一个新对象,这个对象的原型指向函数的<code data-v-8b43f027>prototype</code>属性。</p><div class="code-example" data-v-8b43f027><h3 data-v-8b43f027>构造函数示例</h3><pre data-v-8b43f027><code data-v-8b43f027>// 构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// 在原型上添加方法
Person.prototype.greet = function() {
  return `你好,我是${this.name},今年${this.age}岁`;
};

// 创建实例
const person1 = new Person(&#39;李四&#39;, 25);
const person2 = new Person(&#39;王五&#39;, 30);

console.log(person1.greet()); // 你好,我是李四,今年25岁
console.log(person2.greet()); // 你好,我是王五,今年30岁

// 检查原型关系
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.isPrototypeOf(person1)); // true
console.log(person1 instanceof Person); // true</code></pre></div></section><section class="content-section" data-v-8b43f027><h2 data-v-8b43f027>ES6类与原型</h2><p data-v-8b43f027>ES6引入了<code data-v-8b43f027>class</code>语法糖,使得基于原型的继承更加直观和易于理解。但需要注意的是,class本质上仍然是基于原型的语法糖。</p><div class="code-example" data-v-8b43f027><h3 data-v-8b43f027>ES6类示例</h3><pre data-v-8b43f027><code data-v-8b43f027>class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name}发出声音`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
  
  speak() {
    return `${this.name}汪汪叫`;
  }
  
  fetch() {
    return `${this.name}正在取回球`;
  }
}

const myDog = new Dog(&#39;Buddy&#39;, &#39;金毛&#39;);
console.log(myDog.speak()); // Buddy汪汪叫
console.log(myDog.fetch()); // Buddy正在取回球
console.log(myDog instanceof Dog); // true
console.log(myDog instanceof Animal); // true

// 检查原型链
console.log(Object.getPrototypeOf(myDog) === Dog.prototype); // true
console.log(Object.getPrototypeOf(Dog.prototype) === Animal.prototype); // true</code></pre></div></section><section class="content-section" data-v-8b43f027><h2 data-v-8b43f027>原型链的终点</h2><p data-v-8b43f027>所有原型链的终点都是<code data-v-8b43f027>Object.prototype</code>,而<code data-v-8b43f027>Object.prototype</code>的原型是<code data-v-8b43f027>null</code>。这意味着所有对象都继承自<code data-v-8b43f027>Object.prototype</code>,因此可以访问诸如<code data-v-8b43f027>toString()</code>、<code data-v-8b43f027>hasOwnProperty()</code>等方法。 </p><div class="code-example" data-v-8b43f027><h3 data-v-8b43f027>原型链终点示例</h3><pre data-v-8b43f027><code data-v-8b43f027>function Example() {
  this.value = 42;
}

const ex = new Example();

// 检查原型链
console.log(ex.__proto__ === Example.prototype); // true
console.log(Example.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true

// 所有对象都继承Object.prototype的方法
console.log(ex.toString()); // [object Object]
console.log(ex.hasOwnProperty(&#39;value&#39;)); // true
console.log(ex.hasOwnProperty(&#39;toString&#39;)); // false (继承方法)</code></pre></div></section><section class="content-section" data-v-8b43f027><h2 data-v-8b43f027>原型在实际开发中的应用</h2><h3 data-v-8b43f027>1. 方法共享与内存优化</h3><p data-v-8b43f027>将方法定义在原型上可以让所有实例共享同一方法,节省内存。</p><h3 data-v-8b43f027>2. 扩展内置对象</h3><p data-v-8b43f027>通过原型可以扩展JavaScript内置对象的功能（需谨慎使用）。</p><h3 data-v-8b43f027>3. 实现继承和多态</h3><p data-v-8b43f027>原型链是实现JavaScript中继承和多态的基础机制。</p><div class="code-example" data-v-8b43f027><h3 data-v-8b43f027>方法共享示例</h3><pre data-v-8b43f027><code data-v-8b43f027>// 不推荐的方式:每个实例都有独立的函数副本
function InefficientPerson(name) {
  this.name = name;
  this.greet = function() {
    return `你好,我是${this.name}`;
  };
}

// 推荐的方式:方法定义在原型上,所有实例共享
function EfficientPerson(name) {
  this.name = name;
}

EfficientPerson.prototype.greet = function() {
  return `你好,我是${this.name}`;
};

const p1 = new InefficientPerson(&#39;张三&#39;);
const p2 = new InefficientPerson(&#39;李四&#39;);
console.log(p1.greet === p2.greet); // false - 不同函数实例

const p3 = new EfficientPerson(&#39;王五&#39;);
const p4 = new EfficientPerson(&#39;赵六&#39;);
console.log(p3.greet === p4.greet); // true - 共享同一函数</code></pre></div></section><section class="conclusion" data-v-8b43f027><h2 data-v-8b43f027>总结</h2><p data-v-8b43f027>原型和原型链是JavaScript中对象继承的核心机制。理解原型链对于掌握JavaScript至关重要,它解释了JavaScript中对象如何继承属性和方法。</p><p data-v-8b43f027>关键要点:</p><ul data-v-8b43f027><li data-v-8b43f027>每个对象都有一个原型（通过<code data-v-8b43f027>__proto__</code>访问）,构造函数有一个<code data-v-8b43f027>prototype</code>属性</li><li data-v-8b43f027>当访问对象属性时,JavaScript会沿着原型链向上查找</li><li data-v-8b43f027>所有原型链的终点都是<code data-v-8b43f027>Object.prototype</code>,其原型为<code data-v-8b43f027>null</code></li><li data-v-8b43f027>ES6的<code data-v-8b43f027>class</code>语法是基于原型的语法糖</li><li data-v-8b43f027>将方法定义在原型上可以提高内存效率</li></ul><p data-v-8b43f027>深入理解原型和原型链将帮助你编写更高效、更优雅的JavaScript代码,并更好地理解JavaScript的语言特性。</p></section></article></main></div><footer class="footer_cus" data-v-a2616516><div class="logoRow"><a href="/" title="Home Page"><div class="logo_fTitle"><img src="/assets/favicon.DAnBlHWS.png" alt="feexp 网站logo | fe-exp专注前端开发,分享技术干货。" class="logo"><div class="title">FEEXP</div></div></a><div class="menubox_f"><a href="/articlesList" title="Articles List"><div class="menu">Articles</div></a><a href="/onlineTools" title="Online Tools"><div class="menu">Online Tools</div></a><a href="/about" title="About"><div class="menu">About</div></a></div></div><div class="copyright">Copyright © 2025 feexp.github.io Individuals and their licensors. All rights reserved.</div></footer><div class="bg" data-v-a2616516><video autoplay class="bg_video" muted loop width="100%" data-v-a2616516><source src="/assets/bg.PfeklyBa.mp4" data-v-a2616516></video></div></div></div><div id="teleports"></div><script type="application/json" data-nuxt-data="nuxt-app" data-ssr="true" id="__NUXT_DATA__" data-src="/articlesList/prototype/_payload.json?d8732c21-408f-4757-a05a-6bb9ca98505a">[{"state":1,"once":3,"_errors":4,"serverRendered":6,"path":7,"prerenderedAt":8},["Reactive",2],{},["Set"],["ShallowReactive",5],{},true,"/articlesList/prototype",1758186392757]</script><script>window.__NUXT__={};window.__NUXT__.config={public:{supabase:{url:"",key:""}},app:{baseURL:"/",buildId:"d8732c21-408f-4757-a05a-6bb9ca98505a",buildAssetsDir:"assets",cdnURL:""}}</script></body></html>