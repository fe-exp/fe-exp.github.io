<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="importmap">{"imports":{"#entry":"/assets/BgnhDj_w.js"}}</script><title>JavaScript事件循环:深入理解异步编程的核心机制 | 前端技术博客</title><style>a,article,aside,body,details,figcaption,figure,footer,h1,h2,h3,h4,h5,h6,header,main,mark,nav,output,section,summary,time{all:unset;background:none;border:none;color:inherit;display:block;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;padding:0;text-decoration:none}body{font-size:14px}</style><style>.defaultTheme[data-v-a2616516]{position:relative;width:100%}.defaultTheme .bg[data-v-a2616516]{inset:0;overflow:hidden;position:absolute;width:100%;z-index:-10}</style><style>.default_header{align-items:center;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);background-color:#ffffff50;box-sizing:border-box;display:flex;height:5.21vw;justify-content:space-between;padding:0 3.5428vw;position:static;top:0;width:100%;z-index:10}.default_header .logo_title{align-items:center;cursor:pointer;display:flex}.default_header .logo_title .logo{margin-right:.7815vw;width:5.21vw}.default_header .logo_title .title{color:#fff;font-size:4.8em;font-weight:700;transform:translateY(-4px)}.default_header .menubox{align-items:center;color:#fff;-moz-column-gap:3.5428vw;column-gap:3.5428vw;cursor:pointer;display:flex;font-size:1.3em}</style><style>.event-loop-page[data-v-b8297c30]{background-color:#f8f9fa;box-sizing:border-box;color:#333;font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;line-height:1.6;padding-top:20px}.container[data-v-b8297c30]{margin:0 auto;max-width:1000px;padding:0 20px}h1[data-v-b8297c30]{font-size:2.5rem;font-weight:700;margin:0 0 30px;text-align:center;width:100%}.main[data-v-b8297c30]{padding-bottom:3rem}.article[data-v-b8297c30]{background:#fff;border-radius:8px;box-shadow:0 4px 6px #0000001a;padding:2rem}.article section[data-v-b8297c30]{margin-bottom:2.5rem}.article section[data-v-b8297c30]:last-child{margin-bottom:0}.article h2[data-v-b8297c30]{border-bottom:2px solid #e9ecef;color:#ff6b6b;margin-top:0;padding-bottom:.5rem}.article h3[data-v-b8297c30]{color:#495057;margin-top:1.5rem}.article h4[data-v-b8297c30]{color:#6c757d;margin-bottom:.5rem;margin-top:1rem}.intro[data-v-b8297c30]{font-size:1.1rem;font-weight:500}.visualization[data-v-b8297c30]{background:#f8f9fa;border-radius:8px;margin:2rem 0;padding:1.5rem}.visualization h3[data-v-b8297c30]{color:#ff6b6b;margin-top:0;text-align:center}.diagram[data-v-b8297c30]{display:grid;gap:1.5rem;grid-template-columns:1fr 1fr;grid-template-rows:auto auto auto;margin-top:1.5rem}.diagram .call-stack[data-v-b8297c30],.diagram .event-loop[data-v-b8297c30],.diagram .queues[data-v-b8297c30],.diagram .web-apis[data-v-b8297c30]{background:#fff;border-radius:6px;box-shadow:0 2px 4px #0000000d;padding:1rem}.diagram .call-stack[data-v-b8297c30]{grid-column:1;grid-row:1}.diagram .web-apis[data-v-b8297c30]{grid-column:2;grid-row:1}.diagram .queues[data-v-b8297c30]{display:flex;gap:1rem;grid-column:1/span 2;grid-row:2}.diagram .queues .queue[data-v-b8297c30]{border-radius:6px;flex:1;padding:1rem}.diagram .queues .queue.microtask[data-v-b8297c30]{background:#e3f2fd}.diagram .queues .queue.macrotask[data-v-b8297c30]{background:#ffebee}.diagram .event-loop[data-v-b8297c30]{background:#fff8e1;font-weight:700;grid-column:1/span 2;grid-row:3;text-align:center}.api-items[data-v-b8297c30],.queue-items[data-v-b8297c30],.stack-items[data-v-b8297c30]{border:1px dashed #dee2e6;border-radius:4px;min-height:100px;padding:.5rem}.api-items .api-item[data-v-b8297c30],.api-items .queue-item[data-v-b8297c30],.api-items .stack-item[data-v-b8297c30],.queue-items .api-item[data-v-b8297c30],.queue-items .queue-item[data-v-b8297c30],.queue-items .stack-item[data-v-b8297c30],.stack-items .api-item[data-v-b8297c30],.stack-items .queue-item[data-v-b8297c30],.stack-items .stack-item[data-v-b8297c30]{background:#e9ecef;border-radius:4px;font-size:.9rem;margin:.25rem 0;padding:.5rem}.code-example[data-v-b8297c30]{background:#f8f9fa;border-left:4px solid #ff6b6b;border-radius:0 4px 4px 0;margin:1.5rem 0;padding:1rem}.code-example h3[data-v-b8297c30]{color:#ff6b6b;margin-top:0}.code-example pre[data-v-b8297c30]{background:#2d2d2d;border-radius:4px;color:#f8f9fa;margin:0;overflow-x:auto;padding:1rem}.code-example pre code[data-v-b8297c30]{font-family:Fira Code,monospace;font-size:.9rem;line-height:1.5}ol[data-v-b8297c30],ul[data-v-b8297c30]{padding-left:1.5rem}ol li[data-v-b8297c30],ul li[data-v-b8297c30]{margin-bottom:.5rem}.conclusion[data-v-b8297c30]{background:#fff8e1;border-radius:8px;padding:1.5rem}.conclusion h2[data-v-b8297c30]{border-bottom:none;color:#ff8e53}@media (max-width:768px){.header[data-v-b8297c30]{padding:2rem 0}.header h1[data-v-b8297c30]{font-size:2rem}.article[data-v-b8297c30]{padding:1.5rem}.diagram[data-v-b8297c30]{grid-template-columns:1fr;grid-template-rows:auto auto auto auto}.diagram .call-stack[data-v-b8297c30]{grid-column:1;grid-row:1}.diagram .web-apis[data-v-b8297c30]{grid-column:1;grid-row:2}.diagram .queues[data-v-b8297c30]{flex-direction:column;grid-column:1;grid-row:3}.diagram .event-loop[data-v-b8297c30]{grid-column:1;grid-row:4}.code-example pre code[data-v-b8297c30]{font-size:.8rem}}.content-section[data-v-b8297c30]{transition:transform .3s ease}.content-section[data-v-b8297c30]:hover{transform:translate(5px)}.code-example pre[data-v-b8297c30]{transition:background-color .3s ease}.code-example pre[data-v-b8297c30]:hover{background-color:#3d3d3d}.api-item[data-v-b8297c30],.queue-item[data-v-b8297c30],.stack-item[data-v-b8297c30]{transition:transform .2s ease}.api-item[data-v-b8297c30]:hover,.queue-item[data-v-b8297c30]:hover,.stack-item[data-v-b8297c30]:hover{box-shadow:0 2px 4px #0000001a;transform:scale(1.02)}</style><style>.footer_cus{background-color:#efefef;box-sizing:border-box;flex-direction:column;height:10.42vw;padding-top:1.8756vw;width:100%}.footer_cus,.footer_cus .logoRow{display:flex;justify-content:space-between}.footer_cus .logoRow{align-items:center;padding:0 6.6688vw}.footer_cus .logoRow .logo_fTitle{align-items:center;cursor:pointer;display:flex}.footer_cus .logoRow .logo_fTitle .logo{margin-right:.7815vw;width:5.21vw}.footer_cus .logoRow .logo_fTitle .title{color:#000;font-size:4.8em;font-weight:700;transform:translateY(-4px)}.footer_cus .logoRow .menubox_f{align-items:center;color:#000;-moz-column-gap:3.5428vw;column-gap:3.5428vw;cursor:pointer;display:flex;font-size:1.3em}.footer_cus .copyright{border-top:1px solid rgba(0,0,0,.063);color:#00000090;font-size:.8em;line-height:1.563vw;margin-top:auto;text-align:center;width:100%}</style><link rel="stylesheet" href="/assets/entry.kJVMq65g.css" crossorigin><link rel="preload" as="fetch" crossorigin="anonymous" href="/articlesList/event-loop/_payload.json?170374c3-fb44-4b63-be03-ff111dc4c848"><link rel="modulepreload" as="script" crossorigin href="/assets/BgnhDj_w.js"><link rel="modulepreload" as="script" crossorigin href="/assets/DW9A0CUQ.js"><link rel="modulepreload" as="script" crossorigin href="/assets/BA7K0eZI.js"><link rel="modulepreload" as="script" crossorigin href="/assets/BxipngAD.js"><link rel="preload" as="fetch" fetchpriority="low" crossorigin="anonymous" href="/assets/builds/meta/170374c3-fb44-4b63-be03-ff111dc4c848.json"><link rel="prefetch" as="script" crossorigin href="/assets/CDGrM_S6.js"><link rel="prefetch" as="script" crossorigin href="/assets/Bm2hnUHE.js"><link rel="prefetch" as="image" type="image/png" href="/assets/favicon.DAnBlHWS.png"><link rel="prefetch" as="video" href="/assets/bg.PfeklyBa.mp4"><meta name="title" content="fe-exp"><meta name="keywords" content="JavaScript事件循环, 异步编程, 微任务, 宏任务, Promise, setTimeout, 前端开发, Node.js事件循环"><meta name="description" content="本文深入探讨JavaScript事件循环的概念、工作原理、微任务与宏任务的区别以及实际应用。掌握JavaScript异步编程的核心机制。"><meta property="og:title" content="JavaScript事件循环:深入理解异步编程的核心机制"><meta property="og:description" content="全面解析JavaScript事件循环的概念、工作原理和应用场景,帮助开发者掌握JavaScript异步编程的核心机制。"><meta property="og:type" content="article"><meta property="og:url" content="https://yourwebsite.com/articles/javascript-event-loop"><meta property="og:image" content="https://yourwebsite.com/images/javascript-event-loop-article.jpg"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="JavaScript事件循环:深入理解异步编程的核心机制"><meta name="twitter:description" content="全面解析JavaScript事件循环的概念、工作原理和应用场景,帮助开发者掌握JavaScript异步编程的核心机制。"><meta name="twitter:image" content="https://yourwebsite.com/images/javascript-event-loop-article.jpg"><script type="module" src="/assets/BgnhDj_w.js" crossorigin></script></head><body><div id="__nuxt"><div class="defaultTheme" data-v-a2616516><header class="default_header" data-v-a2616516><a href="/" title="Home Page"><div class="logo_title"><img src="/assets/favicon.DAnBlHWS.png" alt="feexp 网站logo | fe-exp专注前端开发,分享技术干货。" class="logo"><div class="title">FEEXP</div></div></a><div class="menubox"><a href="/" title="Home Page"><div class="menu">Home</div></a><a href="/articlesList" title="Articles List"><div class="menu">Articles</div></a><a href="/onlineTools" title="Online Tools"><div class="menu">Online Tools</div></a><a href="/about" title="About"><div class="menu">About</div></a></div></header><div class="event-loop-page" data-v-b8297c30><h1 data-v-b8297c30>JavaScript事件循环:深入理解异步编程的核心机制</h1><main class="main container" data-v-b8297c30><article class="article" data-v-b8297c30><section class="intro" data-v-b8297c30><p data-v-b8297c30>事件循环是JavaScript异步编程的核心概念,它使得JavaScript能够在单线程环境中处理非阻塞I/O操作。理解事件循环对于编写高效、响应迅速的JavaScript应用程序至关重要。本文将深入探讨事件循环的工作原理、任务队列、微任务与宏任务的区别以及实际应用。</p></section><section class="content-section" data-v-b8297c30><h2 data-v-b8297c30>什么是事件循环？</h2><p data-v-b8297c30><strong data-v-b8297c30>事件循环</strong>是JavaScript运行时的一种机制,负责处理代码执行、收集和处理事件以及执行队列中的子任务。尽管JavaScript是单线程的,但事件循环允许它通过非阻塞I/O操作来处理并发。</p><div class="visualization" data-v-b8297c30><h3 data-v-b8297c30>事件循环简化模型</h3><div class="diagram" data-v-b8297c30><div class="call-stack" data-v-b8297c30><h4 data-v-b8297c30>调用栈 (Call Stack)</h4><div class="stack-items" data-v-b8297c30><!--[--><div class="stack-item" data-v-b8297c30>main()</div><div class="stack-item" data-v-b8297c30>console.log()</div><!--]--></div></div><div class="web-apis" data-v-b8297c30><h4 data-v-b8297c30>Web APIs</h4><div class="api-items" data-v-b8297c30><!--[--><div class="api-item" data-v-b8297c30>setTimeout</div><div class="api-item" data-v-b8297c30>Promise</div><!--]--></div></div><div class="queues" data-v-b8297c30><div class="queue microtask" data-v-b8297c30><h4 data-v-b8297c30>微任务队列 (Microtask Queue)</h4><div class="queue-items" data-v-b8297c30><!--[--><div class="queue-item" data-v-b8297c30>Promise回调</div><!--]--></div></div><div class="queue macrotask" data-v-b8297c30><h4 data-v-b8297c30>宏任务队列 (Macrotask Queue)</h4><div class="queue-items" data-v-b8297c30><!--[--><div class="queue-item" data-v-b8297c30>setTimeout回调</div><!--]--></div></div></div><div class="event-loop" data-v-b8297c30><h4 data-v-b8297c30>事件循环 (Event Loop)</h4></div></div></div></section><section class="content-section" data-v-b8297c30><h2 data-v-b8297c30>调用栈、Web API和任务队列</h2><p data-v-b8297c30>要理解事件循环,首先需要了解几个核心概念:</p><h3 data-v-b8297c30>1. 调用栈 (Call Stack)</h3><p data-v-b8297c30>调用栈是一种数据结构,用于跟踪当前正在执行的函数。当一个函数被调用时,它会被添加到栈顶；当函数执行完成后,它会从栈中移除。</p><h3 data-v-b8297c30>2. Web APIs</h3><p data-v-b8297c30>浏览器提供的API,如setTimeout、DOM事件、AJAX请求等。这些API允许JavaScript执行异步操作。</p><h3 data-v-b8297c30>3. 任务队列 (Task Queue)</h3><p data-v-b8297c30>当异步操作完成时,对应的回调函数会被添加到任务队列中。事件循环会定期检查调用栈是否为空,如果为空,则将队列中的回调函数推入调用栈执行。</p><div class="code-example" data-v-b8297c30><h3 data-v-b8297c30>事件循环示例</h3><pre data-v-b8297c30><code data-v-b8297c30>console.log(&#39;开始&#39;);

setTimeout(function timeoutCallback() {
  console.log(&#39;setTimeout&#39;);
}, 0);

Promise.resolve().then(function promiseCallback() {
  console.log(&#39;Promise&#39;);
});

console.log(&#39;结束&#39;);

// 输出顺序:
// 开始
// 结束
// Promise
// setTimeout</code></pre></div></section><section class="content-section" data-v-b8297c30><h2 data-v-b8297c30>微任务与宏任务</h2><p data-v-b8297c30>事件循环中有两种主要的任务类型:微任务(Microtasks)和宏任务(Macrotasks)。它们的主要区别在于执行时机。</p><h3 data-v-b8297c30>宏任务 (Macrotasks)</h3><ul data-v-b8297c30><li data-v-b8297c30>setTimeout、setInterval</li><li data-v-b8297c30>setImmediate (Node.js)</li><li data-v-b8297c30>I/O操作</li><li data-v-b8297c30>UI渲染</li><li data-v-b8297c30>事件回调</li></ul><h3 data-v-b8297c30>微任务 (Microtasks)</h3><ul data-v-b8297c30><li data-v-b8297c30>Promise回调 (then/catch/finally)</li><li data-v-b8297c30>MutationObserver</li><li data-v-b8297c30>process.nextTick (Node.js)</li><li data-v-b8297c30>queueMicrotask</li></ul><p data-v-b8297c30>事件循环的处理顺序是:执行一个宏任务 → 执行所有微任务 → 渲染UI → 执行下一个宏任务。</p><div class="code-example" data-v-b8297c30><h3 data-v-b8297c30>微任务与宏任务执行顺序</h3><pre data-v-b8297c30><code data-v-b8297c30>console.log(&#39;脚本开始&#39;); // 宏任务

setTimeout(function() {
  console.log(&#39;setTimeout&#39;); // 宏任务
}, 0);

Promise.resolve().then(function() {
  console.log(&#39;Promise 1&#39;); // 微任务
}).then(function() {
  console.log(&#39;Promise 2&#39;); // 微任务
});

console.log(&#39;脚本结束&#39;); // 宏任务

// 输出顺序:
// 脚本开始
// 脚本结束
// Promise 1
// Promise 2
// setTimeout</code></pre></div></section><section class="content-section" data-v-b8297c30><h2 data-v-b8297c30>事件循环的实际应用</h2><h3 data-v-b8297c30>1. 优化性能</h3><p data-v-b8297c30>理解事件循环可以帮助开发者优化应用程序性能,避免长时间运行的同步任务阻塞主线程。</p><h3 data-v-b8297c30>2. 避免界面冻结</h3><p data-v-b8297c30>通过将耗时任务拆分为小块并使用setTimeout或requestAnimationFrame,可以保持界面的响应性。</p><h3 data-v-b8297c30>3. 处理高优先级任务</h3><p data-v-b8297c30>使用微任务可以确保高优先级任务在下一个UI渲染前执行。</p><div class="code-example" data-v-b8297c30><h3 data-v-b8297c30>使用requestAnimationFrame优化动画</h3><pre data-v-b8297c30><code data-v-b8297c30>function animate() {
  // 执行动画逻辑
  element.style.left = `${position}px`;
  
  position += 1;
  
  if (position &lt; 100) {
    requestAnimationFrame(animate);
  }
}

// 启动动画
requestAnimationFrame(animate);</code></pre></div></section><section class="content-section" data-v-b8297c30><h2 data-v-b8297c30>Node.js中的事件循环</h2><p data-v-b8297c30>Node.js也使用事件循环,但其实现与浏览器略有不同。Node.js的事件循环分为多个阶段:</p><ol data-v-b8297c30><li data-v-b8297c30><strong data-v-b8297c30>timers</strong>:执行setTimeout和setInterval的回调</li><li data-v-b8297c30><strong data-v-b8297c30>pending callbacks</strong>:执行延迟到下一个循环迭代的I/O回调</li><li data-v-b8297c30><strong data-v-b8297c30>idle, prepare</strong>:仅系统内部使用</li><li data-v-b8297c30><strong data-v-b8297c30>poll</strong>:检索新的I/O事件,执行I/O相关回调</li><li data-v-b8297c30><strong data-v-b8297c30>check</strong>:执行setImmediate的回调</li><li data-v-b8297c30><strong data-v-b8297c30>close callbacks</strong>:执行关闭事件的回调,如socket.on(&#39;close&#39;, ...)</li></ol><div class="code-example" data-v-b8297c30><h3 data-v-b8297c30>Node.js事件循环示例</h3><pre data-v-b8297c30><code data-v-b8297c30>const fs = require(&#39;fs&#39;);

console.log(&#39;开始&#39;);

// 下一个tick执行
process.nextTick(() =&gt; {
  console.log(&#39;nextTick回调&#39;);
});

// 立即执行
setImmediate(() =&gt; {
  console.log(&#39;setImmediate回调&#39;);
});

// 定时器
setTimeout(() =&gt; {
  console.log(&#39;setTimeout回调&#39;);
}, 0);

// I/O操作
fs.readFile(__filename, () =&gt; {
  console.log(&#39;文件读取完成&#39;);
  
  setTimeout(() =&gt; {
    console.log(&#39;setTimeout在readFile中&#39;);
  }, 0);
  
  setImmediate(() =&gt; {
    console.log(&#39;setImmediate在readFile中&#39;);
  });
});

console.log(&#39;结束&#39;);</code></pre></div></section><section class="content-section" data-v-b8297c30><h2 data-v-b8297c30>常见事件循环面试题</h2><div class="code-example" data-v-b8297c30><h3 data-v-b8297c30>面试题1: 执行顺序分析</h3><pre data-v-b8297c30><code data-v-b8297c30>console.log(&#39;1&#39;);

setTimeout(() =&gt; {
  console.log(&#39;2&#39;);
  Promise.resolve().then(() =&gt; {
    console.log(&#39;3&#39;);
  });
}, 0);

setTimeout(() =&gt; {
  console.log(&#39;4&#39;);
}, 0);

Promise.resolve().then(() =&gt; {
  console.log(&#39;5&#39;);
});

console.log(&#39;6&#39;);

// 输出顺序: 1, 6, 5, 2, 3, 4</code></pre></div><div class="code-example" data-v-b8297c30><h3 data-v-b8297c30>面试题2: 异步与同步混合</h3><pre data-v-b8297c30><code data-v-b8297c30>async function async1() {
  console.log(&#39;async1 start&#39;);
  await async2();
  console.log(&#39;async1 end&#39;);
}

async function async2() {
  console.log(&#39;async2&#39;);
}

console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;setTimeout&#39;);
}, 0);

async1();

new Promise(function(resolve) {
  console.log(&#39;promise1&#39;);
  resolve();
}).then(function() {
  console.log(&#39;promise2&#39;);
});

console.log(&#39;script end&#39;);

// 输出顺序:
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout</code></pre></div></section><section class="conclusion" data-v-b8297c30><h2 data-v-b8297c30>总结</h2><p data-v-b8297c30>事件循环是JavaScript异步编程的核心机制,它使得单线程的JavaScript能够处理非阻塞I/O操作。理解事件循环的工作原理、微任务与宏任务的执行顺序,对于编写高效、响应迅速的JavaScript应用程序至关重要。</p><p data-v-b8297c30>关键要点:</p><ul data-v-b8297c30><li data-v-b8297c30>JavaScript是单线程的,但通过事件循环可以实现异步操作</li><li data-v-b8297c30>调用栈用于跟踪当前执行的函数,Web APIs提供异步功能,任务队列存储待执行的回调</li><li data-v-b8297c30>微任务优先于宏任务执行,每个宏任务执行后都会清空微任务队列</li><li data-v-b8297c30>Promise、MutationObserver等产生微任务,setTimeout、setInterval等产生宏任务</li><li data-v-b8297c30>Node.js的事件循环与浏览器略有不同,分为多个阶段</li></ul><p data-v-b8297c30>深入理解事件循环将帮助你编写更高效、更可靠的JavaScript代码,并更好地调试异步相关问题。</p></section></article></main></div><footer class="footer_cus" data-v-a2616516><div class="logoRow"><a href="/" title="Home Page"><div class="logo_fTitle"><img src="/assets/favicon.DAnBlHWS.png" alt="feexp 网站logo | fe-exp专注前端开发,分享技术干货。" class="logo"><div class="title">FEEXP</div></div></a><div class="menubox_f"><a href="/articlesList" title="Articles List"><div class="menu">Articles</div></a><a href="/onlineTools" title="Online Tools"><div class="menu">Online Tools</div></a><a href="/about" title="About"><div class="menu">About</div></a></div></div><div class="copyright">Copyright © 2025 feexp.github.io Individuals and their licensors. All rights reserved.</div></footer><div class="bg" data-v-a2616516><video autoplay class="bg_video" muted loop width="100%" data-v-a2616516><source src="/assets/bg.PfeklyBa.mp4" data-v-a2616516></video></div></div></div><div id="teleports"></div><script type="application/json" data-nuxt-data="nuxt-app" data-ssr="true" id="__NUXT_DATA__" data-src="/articlesList/event-loop/_payload.json?170374c3-fb44-4b63-be03-ff111dc4c848">[{"state":1,"once":3,"_errors":4,"serverRendered":6,"path":7,"prerenderedAt":8},["Reactive",2],{},["Set"],["ShallowReactive",5],{},true,"/articlesList/event-loop",1758185022310]</script><script>window.__NUXT__={};window.__NUXT__.config={public:{supabase:{url:"",key:""}},app:{baseURL:"/",buildId:"170374c3-fb44-4b63-be03-ff111dc4c848",buildAssetsDir:"assets",cdnURL:""}}</script></body></html>